# Software-Testing

## Junior QA requirements

### Основы, определения, виды тестирования
Качество ПО - это совокупность характеристик ПО, относящихся к его способности удовлетворять установленные и предполагаемые потребности.  
Обеспечение качества (QA) - комплекс мероприятий направленный на обеспечение качества разрабатываемого продукта, на всех стадиях разработки.   
Тестирование ПО (Software Testing) – процесс анализа программного средства и сопутствующей документации с целью выявления дефектов и повышения качества продукта.  
Quality Control направлено на поиск дефектов в готовом продукте для того, чтобы убедиться, что продукт соответствует требованиям и готов к передаче пользователю (заказчику).  
Quality Assurance направлено больше на процессы, их усовершенствование (оптимизацию) для минимизации количества багов (дефектов) в самом начале разработки продукта. Это довольно эффективно, так как анализируются все аспекты в самом начале, а не когда продукт готов и выясняется, что работать с ним не совсем удобно или можно реализовать функциональность по-другому.  

#### Объекты тестирования
* Программы при их непосредственном запуске и исполнении (software).
* Код программ без запуска и исполнения (code).
* Прототип программного продукта (product prototype). 
* Проектная документация (project documentation):
  * Требования к продукту (product requirements).
  * Функциональные  спецификации к продукту (functional specifications).
  * Документы по архитектуре (product architecture) и дизайну (product design).
  * План проекта (project plan).
  * Тестовые сценарии (test cases).
* Сопроводительная документация:
  * Интерактивная помощь (on-line help).
  * Руководства  по  установке  (Installation guide)  и  использованию (user manual).

#### Этапы тестирования (жизненный цикл тестирования)
* Анализ требований. Изучаем спецификации требований, функциональные требования к системе. Отвечаем на вопросы: что нам предстоит тестировать, как много будет работы, какие есть сложности, всё ли необходимое у нас есть. Получаем данные, по которым составляем план тестирования.
* Планирование испытаний. Определяем объемы испытаний и ресурсы, пишем расписание того, когда будем выполнять намеченные действия.
* Проектирование тестов. Определяем: цель тестирования, специфику входных данных (классы эквивалентности...), модули и подмодули приложения, архитектуру проверок (группы чек-листов), архитектуру тестов (детализация от крупного к деталям). Пишем тесты.
* Запуск тестов. Проверяем тесты в действии, анализируем тестовые результаты.
* Редактирование тестов. Пересматриваем и корректируем тесты, держим тесты в актуальном состоянии, дополняем новыми тестами.
* Системное тестирование. Проверяем всю систему (все модули нашего продукта как единую систему), получаем сведения о качестве ПО. 
* Приемочные испытания (альфа и бета тестирование).
* Эксплуатация и сопровождение. Тестирование багов, найденных в релизном продукте, регрессионное тестирование билда после внесенных исправлений (regression testing).

#### Виды тестирования
##### По методу тестирования
Мы работаем с кодом системы?
* НЕТ = метод «черного» ящика (black-box)
* Частично = метод «серого» ящика (grey-box)
* ДА = метод «белого» ящика (white-box)

##### По уровню (вширь)
* Компонентное/модульное (component/unit testing). Каждая сложная программная система состоит из отдельных частей – модулей, выполняющих ту или иную функцию в составе системы. Для того, чтобы удостовериться в корректной работе системы в целом, необходимо вначале протестировать каждый модуль системы по отдельности. 
* Интеграционное (integration testing). Результатом тестирования и верификации отдельных модулей, составляющих программную систему, является заключение о том, что эти модули являются внутренне непротиворечивыми и соответствуют требованиям. Однако отдельные модули редко функционируют сами по себе, поэтому следующая задача после тестирования отдельных модулей – тестирование корректности взаимодействия нескольких модулей, объединенных в единое целое. Такое тестирование называют интеграционным. Его цель – удостовериться в корректности совместной работы компонент системы.
* Системное (system testing). На этом этапе проводится не только функциональное тестирование, но и оценка характеристик качества системы – ее устойчивости, надежности, безопасности и производительности. На этом этапе выявляются многие проблемы внешних интерфейсов системы, связанные с неверным взаимодействием с другими системами, аппаратным обеспечением, неверным распределением памяти, отсутствием корректного освобождения ресурсов и т.п.

##### По уровню (вглубь)
* Приемочное (smoke test, acceptance testing) - проверка самой важной функциональности программного продукта.
* Тест критического пути (critical path test) – проверка функциональности, используемой типичными пользователями в повседневной деятельности.
* Расширенный тест (extended test) – проверка всей заявленной функциональности.

##### По цели
* Функциональное
  * Функциональное тестирование (functional testing)
  * Тестирование новой функциональности (new feature testing)
  * Тестирование безопасности (security testing)
 
* Нефункциональное
  * Производительности (performance testing) - определить, как быстро работает система или её часть под определённой нагрузкой:
    * нагрузочное (performance & load testing) - автоматизированное тестирование, которое имитирует одновременную работу множества пользователей над приложением;
    * стрессовое ( stress testing) позволяет проверить насколько приложение (система в целом) работоспособны в условиях стресса, и также оценить способность системы к регенерации (возвращение к нормальному состоянию после прекращения стресса);
    * тестирование стабильности / надежности (stability / reliability testing)  проверка работоспособности приложения при длительном (многочасовом) тестировании со средним уровнем нагрузки;
    * тестирование объемами (volume testing) оценить производительность при увеличении объемов данных в базах данных приложения.
  * Установочное (installation testing) направлено на проверку успешной инсталляции и настройки, а также обновления и удаления ПО.
  * Удобства пользования (usability testing) - тестирование, показывающее степень удобства использования, обучаемости, понятности и привлекательности для пользователя разрабатываемого ПО в контексте определенных условий.
  * Тестирование на отказ и восстановление (failover & recovery testing) проверяет продукт с точки зрения способности противостоять и успешно восстанавливаться после сбоев, возникших в связи с ошибками ПО, отказами оборудования или проблемами связи (например, отказ сети). 
  * Конфигурационное (configuration testing) - специальный вид тестирования, направленный на проверку работы программного обеспечения при различных конфигурациях системы (заявленных платформах, поддерживаемых драйверах, при различных конфигурациях компьютеров ...).
  * Интернационализации (internationalization testing) проверяет  готовность  приложения  к  работе  с разными языковвыми интерфейсами.
  * Локализационное (localization testing) проверяет, насколько корректно продукт адаптирован к работе на другом языке.
  * Тестирование документации (document testing) – тестирование, с которого начинается почти любой проект. Призвано  обнаружить  ошибки  в  документации на ранних стадиях.
  * Тестирование совместимости (compatibility testing) - тестирование, для проверки корректной работы продукта в определенном окружении.

* Связанное с изменениями
  * Дымовое тестирование (smoke testing) - короткий цикл тестов, чтобы убедиться, что после сборки кода (нового или исправленного) приложение стартует и выполняет основные функции.
  * Регрессионное тестирование (regression testing) - вид тестирования для подтверждения факта, что существующая ранее функциональность работает как и прежде после сделанных в приложении или окружающей среде исправлений или дополнений (починка дефекта, слияние кода, миграция на другую операционную систему, базу данных, веб сервер или сервер приложения).
  * Тестирование сборки (build verification testing) - тестирование выпущенной версии (сборки) по критериям качества для начала тестирования.
  * Проверка согласованности/исправности (sanity testing) - это узконаправленное тестирование, чтобы доказать, что конкретная функция работает согласно заявленным требованиям.

#### Верификация и валидация
Верификация (Verification) — это статическая практика проверки документов, дизайна, архитектуры, кода, т.д.  Отвечает на вопрос “Делаем ли мы продукт правильно?”.  
Валидация (validation) – это процесс оценки конечного продукта, необходимо проверить, соответствует ли программное обеспечение ожиданиям и требованиям клиента. Это динамический механизм проверки и тестирования фактического продукта. Отвечает на вопрос “Делаем ли мы правильный продукт?”.

#### Принципы тестирования
1. Тестирование показывает наличие дефектов. Тестирование может показать наличие дефектов в программе, но не доказать их отсутствие. Тем не менее, важно составлять тест-кейсы, которые будут находить как можно больше багов. Таким образом, при должном тестовом покрытии, тестирование позволяет снизить вероятность наличия дефектов в программном обеспечении. В то же время, даже если дефекты не были найдены в процессе тестирования, нельзя утверждать, что их нет.  
2. Исчерпывающее тестирование невозможно. Невозможно провести исчерпывающее тестирование, которое бы покрывало все комбинации пользовательского ввода и состояний системы, за исключениям совсем уж примитивных случаев. Вместо этого необходимо использовать анализ рисков и расстановку приоритетов, что позволит более эффективно распределять усилия по обеспечению качества ПО.  
3. Раннее тестирование. Тестирование должно начинаться как можно раньше в жизненном цикле разработки программного обеспечения, и его усилия  должны быть сконцентрированы на определенных целях.  
4. Скопление дефектов. Разные модули системы могут содержать разное количество дефектов – то есть, плотность скопления дефектов в разных элементах программы может отличаться. Усилия по тестированию должны распределяться пропорционально фактической плотности дефектов. В основном, большую часть критических дефектов находят в ограниченном количестве модулей. Это проявление принципа Парето: 80% проблем содержатся в 20% модулей.  
5. Парадокс пестицида. Прогоняя одни и те же тесты вновь и вновь, Вы столкнетесь с тем, что они находят все меньше новых ошибок. Поскольку система эволюционирует, многие из ранее найденных дефектов исправляют и старые тест-кейсы больше не срабатывают. Чтобы преодолеть этот парадокс, необходимо периодически вносить изменения в используемые наборы тестов, рецензировать и корректировать их с тем, чтобы они отвечали новому состоянию системы и позволяли находить как можно большее количество дефектов.  
6. Тестирование зависит от контекста. Выбор методологии, техники и типа тестирования будет напрямую зависеть от природы самой программы. Например, программное обеспечение для медицинских нужд требует гораздо более строгой и тщательной проверки, чем, скажем, компьютерная игра. Из тех же соображений, сайт с большой посещаемостью должен пройти через серьезное тестирование производительности, чтобы показать возможность работы в условиях высокой нагрузки.  
7. Заблуждение об отсутствии ошибок. Тот факт, что тестирование не обнаружило дефектов, еще не значит, что программа готова к релизу. Нахождение и исправление дефектов будут не важны, если система окажется неудобной в использовании, и не будет удовлетворять ожиданиям и потребностям пользователя.

### Жизненный цикл разработки ПО и методологии разработки
Цикл (процесс) разработки ПО (software development life cycle) – это путь от идеи до поддержки готового продукта. Чем более отлажены каждая из стадий цикла и координация между ними, тем эффективнее работает компания, тем выше качество и тем счастливее пользователи/клиенты.  

Жизненный цикл ПО:
* Формирование и анализ требований
* Проектирование
* Реализация
* Тестирование продукта
* Внедрение
* Эксплуатация и сопровождение

Когда начинать тестирование: на этапе формирования требований.

Когда заканчивать тестирование:  
* заканчивается выделенное на тестирование время (либо деньги);
* когда видим первую достаточно серьезную проблему;
* в программе слишком много ошибок, так что продолжение тестирования не имеет смысла;
* найдены ответы на все поставленные вопросы;
* заказчик поручил остановить тестирование;
* обнаруживается препятствие (нет информации, которая требуется есть блокирующая ошибка, нет необходимого оборудования или инструментария);
* пауза на то, чтобы выполнить исследования, разработать планы, поразмыслить;
* не осталось вопросов, ответы на которые были бы достаточно ценными, чтобы оправдать стоимость продолжения тестирования.

Модель разработки ПО - структура, систематизирующая различные виды проектной деятельности, их взаимодействие и последовательность в процессе разработки ПО. Выбор той или иной модели зависит от масштаба и сложности проекта, предметной области, доступных ресурсов и множества других факторов.

**Waterfall**  
Каскадная модель (англ. водопад) – модель процесса разработки ПО, в которой весь процесс выглядит как поток, последовательно проходящий фазы анализа требований, проектирования,
реализации, тестирования, интеграции и поддержки. Переход от одной фазы к другой происходит только после полного и успешного завершения предыдущей. Тестирования
подключается с середины. 

![waterfall](https://static.javatpoint.com/tutorial/jira/images/jira-waterfall-model.png)  

**Agile**  
Гибкая методология разработки (англ. гибкий) – серия подходов к разработке ПО, ориентированных на использование итеративной инкрементальной разработки, динамическое формирование требований и обеспечение их реализации в результате постоянного взаимодействия внутри самоорганизующихся рабочих групп, состоящих из специалистов различного профиля.  
Итеративный подход (англ. повторение) в разработке ПО – это выполнение работ параллельно с непрерывным анализом полученных результатов и корректировкой предыдущих этапов работы. 
Инкрементальный подход (англ. увеличение) в разработке ПО – это постепенное прирощение (увеличение) функционала небольшими частями от релиза к релизу.  
Преимущества итеративного подхода:  
* Снижение воздействия серьёзных рисков на ранних стадиях проекта, что ведет к минимизации затрат на их устранение. 
* Организация эффективной обратной связи команды с потребителем/заказчиками и создание продукта, реально отвечающего их потребностям.  
* Акцент усилий на наиболее важных и критичных направлениях проекта.
* Непрерывное итеративное тестирование.
* Раннее обнаружение конфликтов и потенциальных багов.
* Более равномерная загрузка участников проекта.
* Эффективное использование накопленного опыта.
* Реальная оценка текущего состояния проекта.
* Затраты распределяются по всему проекту, а не группируются в конце.

**Scrum**  
Scrum (от англ. scrum «схватка») - методология управления проектами, активно применяющаяся для гибкой разработки ПО. Scrum чётко делает акцент на качественном контроле процесса
разработки.  
Скрам (Scrum) - это набор принципов, на которых строится процесс разработки, позволяющий в жёстко фиксированные и небольшие по времени итерации, называемые спринтами (sprints), предоставлять конечному пользователю работающее ПО с новыми возможностями, для которых определён наибольший приоритет. Новые функции ПО, которые должны быть реализованы в очередном спринте определяются в начале спринта на этапе планирования и не должны изменяться на всём его протяжении. При этом строго фиксированная небольшая длительность спринта придаёт процессу разработки предсказуемость и гибкость.  
Спринт (Sprint) - итерация в скраме, в ходе которой создаётся функциональный прирост ПО. Жёстко фиксирован по времени. Длительность одного спринта от 2 до 4 недель.  
Резерв Проекта (Product backlog) - это список требований к функциональности, упорядоченный по их степени важности, подлежащих реализации. Элементы этого списка называются «пожеланиями пользователя» (user story) или элементами резерва (backlog items).  
Резерв спринта (Sprint backlog) - содержит функциональность, выбранную владельцем проекта из резерва проекта. Все функции разбиты по задачам, каждая из которых оценивается
скрам-командой. Каждый день команда оценивает объем работы, который нужно проделать для завершения спринта.  
Scrum. Встречи:  
* Планирование спринта (Sprint Planning Meeting) - в начале каждого спринта из резерва проекта выбираются задачи, обязательства по выполнению которых за спринт принимает на себя команда. На основе выбранных задач создается резерв спринта. Каждая задача оценивается в идеальных человеко-часах. Решение задачи не должно занимать более 12 часов или одного дня. При необходимости задача разбивается на подзадачи. Обсуждается и определяется, каким образом будет реализован этот объём работ.  
* Ежедневное совещание (Daily Scrum meeting): в течение совещания каждый член команды отвечает на 3 вопроса: Что сделано с момента предыдущего ежедневного совещания? Что будет сделано с момента текущего совещания до следующего? Какие проблемы мешают достижению целей спринта?  
* Обзор итогов спринта (Sprint review meeting) проводится после завершения спринта. Команда демонстрирует инкремент функциональности продукта всем заинтересованным лицам (demo).
* Ретроспективное совещание (Retrospective meeting) проводится после завершения спринта. Члены команды высказывают своё мнение о прошедшем спринте и отвечают на два основных вопроса: Что было сделано хорошо в прошедшем спринте? Что надо улучшить в следующем спринте?  

**Канбан**  
В отличие от Scrum, в команде канбан отсутствуют роли владельца продукта и модератора, а процесс разработки делится не на универсальные спринты, а на стадии выполнения задач («Планируется», «Разрабатывается», «Тестируется», «Завершено»). Жизненный цикл задачи отображается на канбан-доске, физической или электронной. Такая визуализация делает рабочий процесс открытым и понятным для всех участников, что особенно важно в Agile, когда у команды нет одного формального руководителя.  Канбан, как и другие практики бережливого производства, пришедшие из Японии, направлен на достижение баланса и выравнивание нагрузки исполнителей. Эффективность работы оценивается по среднему времени жизни задачи, от начальной до конечной стадии. Если задача прошла весь путь быстро, то команда проекта работала продуктивно и слаженно. Иначе – необходимо решать проблему: искать, где и почему возникли задержки и чью работу надо оптимизировать.

**Техники тест-дизайна**
1. Эквивалентное разбиение. Метод эквивалентного разбиения позволяет минимизировать число тестов, не создавая сценарий для каждого возможного значения, а выбрав только одно значение из целого класса и приняв за аксиому, что для всех значений в данной группе результат будет аналогичным. Например, мы тестируем функциональность приложения, позволяющего покупать авиа- и железнодорожные билеты онлайн. Стоимость билета будет зависеть от возраста пассажира, так как дети, студенты и пенсионеры относятся ко льготным категориям. У нас есть четыре возрастных группы: младше 15 лет, от 15 до 25 лет, старше 25 и младше 60 лет и люди старше 60. При этом, в поле для ввода возраста помещается всего два символа, поэтому указать возраст более 99 лет технически невозможно. QA-специалисту не нужно писать 99 тестов для каждого возраста, хватит пяти: по одному для каждой возрастной группы (скажем, 10, 18, 35 и 75 лет) и один для случая, если возраст человека превышает 99 лет. Да, последний тест на практике невыполним (поскольку в поле возраста невозможно ввести более двух знаков), и все же не следует забывать об этой проверке.  
2. Граничные значения. Техника граничных значений основана на предположении, что большинство ошибок может возникнуть на границах эквивалентных классов. Она тесно связана с  вышеописанной техникой эквивалентного разбиения, из-за чего часто используется с ней в паре. Тогда для примера из предыдущего пункта границами будут являться значения 0, 15, 25, 60 и 99. Граничными значениями будут 0, 1, 14, 15, 16, 24, 25, 26, 59, 60, 61, 98, 99, 100.  
3. Таблица принятия решений. Другое название метода – матрица принятия решений. Эта техника подходит для более сложных систем, например – двухфакторной аутентификации. Предположим, чтобы войти в систему, пользователю нужно ввести сначала логин и пароль, а затем еще подтвердить свою личность присланным в смс кодом. Какие возможны сценарии:
 * Правильный логин и правильный пароль.
 * Правильный логин, неправильный пароль.
 * Неправильный логин, правильный пароль.
 * Неправильный логин, неправильный пароль. 
Первый из этих сценариев сопровождается либо правильным, либо неправильным вводом смс-кода, итого у нас получается 5 тестов. При этом только один из сценариев приведет к положительному результату (пользователь успешно авторизуется), а остальные закончатся неудачей. Однако, может быть так, что система выдает разные сообщения в зависимости от того, на каком этапе была допущена ошибка, скажем: invalid login, invalid password. Соответственно, групп потребуется больше, а таблица станет обширнее. 

![matrix](https://lh5.googleusercontent.com/YlXU5VYh26dT9q5Cw3x3-DonXnNJeX6XVpJH9HeFsuryN9e--J1pnMp3tkllZh3GUQRkc2vg6959Vy_aICGq2ANbK2Do0itlM2xwAOHiYz0nklw-yV-m9O61jmpmAh0dUpdjR0Il)

4. Попарное тестирование. Суть этого метода, также известного как pairwise testing, в том, что каждое значение каждого проверяемого параметра должно быть протестировано на взаимодействие с каждым значением всех остальных параметров. После составления такой матрицы мы убираем тесты, которые дублируют друг друга, оставляя максимальное покрытие при минимальном необходимом наборе сценариев. Попарное тестирование позволяет обнаружить максимум ошибок без избыточных проверок. 
5. Причина и следствие. Простая проверка базовых действий и их результата. Например, если нажать крестик в правом верхнем углу окна (причина), оно закроется (следствие), и т.д. Этот метод позволяет проверить все возможности системы, а также обнаружить баги и улучшить техническую документацию продукта.
6. Предугадывание ошибок. Используя свои знания о системе, QA-специалист может «предугадать», при каких входных условиях есть риск ошибок. Для этого важно иметь опыт, хорошо знать продукт и уметь выстроить коммуникации с коллегами. 

To be updated


